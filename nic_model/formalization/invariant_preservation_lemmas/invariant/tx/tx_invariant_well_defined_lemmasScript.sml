open HolKernel Parse boolLib bossLib;
open helperTactics;
open tx_bd_queueTheory;
open txInvariantWellDefinedTheory;
open bdTheory;
open bd_listTheory;
open tx_state_definitionsTheory;
open tx_state_lemmasTheory;
open bd_queueTheory;
open txTheory;

val _ = new_theory "tx_invariant_well_defined_lemmas";

val TX_INVARIANT_BD_QUEUE_FINITE_EQ_BD_QUEUE_TX_BD_QUEUE_lemma = store_thm (
  "TX_INVARIANT_BD_QUEUE_FINITE_EQ_BD_QUEUE_TX_BD_QUEUE_lemma",
  ``!nic.
    TX_INVARIANT_BD_QUEUE_FINITE nic =
    BD_QUEUE (tx_bd_queue nic) nic.tx.sop_bd_pa nic.regs.CPPI_RAM``,
  GEN_TAC THEN
  EQ_TAC THENL
  [
   DISCH_TAC THEN
   MATCH_MP_TAC TX_BD_QUEUE_IMP_TX_BD_QUEUE_tx_bd_queue_lemma THEN
   ASM_REWRITE_TAC [GSYM TX_INVARIANT_BD_QUEUE_FINITE_def]
   ,
   DISCH_TAC THEN
   REWRITE_TAC [TX_INVARIANT_BD_QUEUE_FINITE_def] THEN
   EXISTS_TAC ``tx_bd_queue nic`` THEN
   ASM_REWRITE_TAC []
  ]);

val TX_LINUX_BD_SOP_EOP_DEPENDS_ONLY_ON_BD_lemma = store_thm (
  "TX_LINUX_BD_SOP_EOP_DEPENDS_ONLY_ON_BD_lemma",
  ``BD_PROPERTY_DEPENDS_ONLY_ON_BD TX_LINUX_BD_SOP_EOP``,
  REWRITE_TAC [BD_PROPERTY_DEPENDS_ONLY_ON_BD_def] THEN
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_EOP_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_def, TX_LINUX_BD_EOP_def, BD_EQ_def] THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL BD_EQ_IMP_TX_BD_EQ_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_LOCATION_DEFINED_IMP_BD_PA_LOCATION_DEFINED_lemma = store_thm (
  "TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_LOCATION_DEFINED_IMP_BD_PA_LOCATION_DEFINED_lemma",
  ``!bd_pa q.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED q
    ==>
    BD_LOCATION_DEFINED bd_pa``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_LOCATION_DEFINED_IMP_BD_PA_IN_CPPI_RAM_lemma = store_thm (
  "TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_LOCATION_DEFINED_IMP_BD_PA_IN_CPPI_RAM_lemma",
  ``!bd_pa q.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED q
    ==>
    BD_IN_CPPI_RAM bd_pa``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  RW_ASM_TAC ``BD_LOCATION_DEFINED bd_pa`` CPPI_RAMTheory.BD_LOCATION_DEFINED_def THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_IMP_BD_QUEUE_IN_CPPI_RAM_lemma = store_thm (
  "TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_IMP_BD_QUEUE_IN_CPPI_RAM_lemma",
  ``!q.
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED q
    ==>
    BDs_IN_CPPI_RAM q``,
  GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_def, BDs_IN_CPPI_RAM_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  REWRITE_TAC [CPPI_RAMTheory.BD_LOCATION_DEFINED_def] THEN
  DISCH_TAC THEN
  GEN_TAC THEN
  DISCH_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``e : 32 word`` thm))) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_TAIL_BD_QUEUE_PRESERVES_BD_QUEUE_LOCATION_DEFINED_lemma = store_thm (
  "TX_INVARIANT_TAIL_BD_QUEUE_PRESERVES_BD_QUEUE_LOCATION_DEFINED_lemma",
  ``!h t.
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (h::t)
    ==>
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED t``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_DEF] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  DISCH_TAC THEN
  REPEAT (PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val disj = (#1 o dest_disj o concl) thm in
      ASSUME_TAC thm THEN
      ASM_CASES_TAC disj THENL
      [
       ASM_REWRITE_TAC []
       ,
       PAT_ASSUM ``~P`` (fn neg => PAT_ASSUM ``P \/ Q`` (fn thm => ASSUME_TAC (REWRITE_RULE [neg] thm)))
      ]
    end)) THEN
  ASM_REWRITE_TAC []);

val TX_STATE_NOT_BD_QUEUE_EMPTY_DEP_lemma = store_thm (
  "TX_STATE_NOT_BD_QUEUE_EMPTY_DEP_lemma",
  ``!nic nic'.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    (nic'.tx = nic.tx)
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_EQ_IMP_TX_STATE_EQ_lemma)) THEN
  REPEAT (PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val tx_state_application = (#1 o dest_disj o concl) thm in
    let val tx_id = txLib.tx_transition_state_application_to_tx_id tx_state_application in
    let val lemma = txLib.get_tx_conjunct TX_STATE_DEP_CONJ_lemmas tx_id in
      ASSUME_TAC thm THEN
      ASM_CASES_TAC tx_state_application THENL
      [
       ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL lemma)) THEN
       ASM_REWRITE_TAC []
       ,
       ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
      ]
    end end end)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_WRITE_CP_DEP_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma = store_thm (
  "TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma",
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic
    ==>
    ?t. tx_bd_queue nic = nic.tx.sop_bd_pa::t``,
  GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``TX_INVARIANT_BD_QUEUE_FINITE nic`` TX_INVARIANT_BD_QUEUE_FINITE_def THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_BD_QUEUE_IMP_tx_bd_queue_lemma)) THEN
  Cases_on `q` THENL
  [
   RW_ASM_TAC ``TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic`` TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_def THEN
   ASM_RW_ASM_TAC ``TX_STATE_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
   RW_ASM_TAC ``NOT_TX_BD_QUEUE_EMPTY nic`` NOT_TX_BD_QUEUE_EMPTY_def THEN
   ASM_RW_ASM_TAC ``tx_bd_queue nic = []`` ``tx_bd_queue nic <> []`` THEN
   UNDISCH_TAC ``F`` THEN
   REWRITE_TAC []
   ,
   ALL_TAC
  ] THEN
  ASSUME_TAC (UNDISCH (SPECL [``h : 32 word``, ``nic.tx.sop_bd_pa``, ``t : 32 word list``, ``nic.regs.CPPI_RAM``] BD_QUEUE_IMP_HEAD_EQ_START_lemma)) THEN
  EXISTS_TAC ``t : 32 word list`` THEN
  ASM_REWRITE_TAC []);

val TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_SOP_BD_PA_BD_QUEUE_lemma = store_thm (
  "TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_SOP_BD_PA_BD_QUEUE_lemma",
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic
    ==>
    MEM nic.tx.sop_bd_pa (tx_bd_queue nic)``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma)) THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASM_REWRITE_TAC [listTheory.MEM]);

val TX_NOT_BD_QUEUE_EMPTY_IMP_CURRENT_BD_PA_HEAD_BD_QUEUE_lemma = prove (
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic
    ==>
    ?t. tx_bd_queue nic = nic.tx.current_bd_pa::t``,
  GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma)))) THEN
  RW_ASM_TAC ``TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic`` TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA_def THEN
  ASM_REWRITE_TAC []);

val TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_CURRENT_BD_PA_BD_QUEUE_lemma = store_thm (
  "TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_CURRENT_BD_PA_BD_QUEUE_lemma",
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic
    ==>
    MEM nic.tx.current_bd_pa (tx_bd_queue nic)``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_CURRENT_BD_PA_HEAD_BD_QUEUE_lemma)) THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASM_REWRITE_TAC [listTheory.MEM]);

val TX_INVARIANT_SOP_EOP_BD_CONSISTENT_SUM_BUFFER_LENGTH_DEPENDS_ONLY_ON_BD_lemma = store_thm (
  "TX_INVARIANT_SOP_EOP_BD_CONSISTENT_SUM_BUFFER_LENGTH_DEPENDS_ONLY_ON_BD_lemma",
  ``BD_PROPERTY_DEPENDS_ONLY_ON_BD TX_INVARIANT_SOP_EOP_BD_CONSISTENT_SUM_BUFFER_LENGTH``,
  REWRITE_TAC [BD_PROPERTY_DEPENDS_ONLY_ON_BD_def] THEN
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL BD_EQ_IMP_TX_BD_EQ_lemma)) THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_CONSISTENT_SUM_BUFFER_LENGTH_def] THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_SOP_EOP_BD_NO_BUFFER_LENGTH_OVERFLOW_DEPENDS_ONLY_ON_BD_lemma = store_thm (
  "TX_INVARIANT_SOP_EOP_BD_NO_BUFFER_LENGTH_OVERFLOW_DEPENDS_ONLY_ON_BD_lemma",
  ``BD_PROPERTY_DEPENDS_ONLY_ON_BD TX_INVARIANT_SOP_EOP_BD_NO_BUFFER_LENGTH_OVERFLOW``,
  REWRITE_TAC [BD_PROPERTY_DEPENDS_ONLY_ON_BD_def] THEN
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL BD_EQ_IMP_TX_BD_EQ_lemma)) THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_NO_BUFFER_LENGTH_OVERFLOW_def] THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_SOP_EOP_MATCH_AND_NO_BUFFER_LENGTH_OVERFLOW_IMP_NOT_TX_BUFFER_LENGTH_OVERFLOW_lemma = prove (
  ``!bd_pa q CPPI_RAM tx.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH q CPPI_RAM /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW q CPPI_RAM
    ==>
    ~TX_BUFFER_LENGTH_OVERFLOW (tx_read_bd bd_pa CPPI_RAM) tx``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_BUFFER_LENGTH_OVERFLOW_def] THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_EOP_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_def] THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_def] THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_NO_BUFFER_LENGTH_OVERFLOW_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  ASM_REWRITE_TAC [] THEN
  REWRITE_TAC [wordsTheory.WORD_HIGHER_EQ] THEN
  REWRITE_TAC [wordsTheory.WORD_NOT_LOWER_EQUAL] THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_SOP_EOP_MATCH_AND_CONSISTENT_SUM_BUFFER_LENGTH_IMP_TX_CONSISTENT_SUM_BUFFER_LENGTH_lemma = prove (
  ``!bd_pa q CPPI_RAM tx.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH q CPPI_RAM /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH q CPPI_RAM
    ==>
    TX_CONSISTENT_SUM_BUFFER_LENGTH (tx_read_bd bd_pa CPPI_RAM) tx``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_CONSISTENT_SUM_BUFFER_LENGTH_def] THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_EOP_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_def] THEN
  REWRITE_TAC [TX_LINUX_BD_EOP_def] THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_def] THEN
  REWRITE_TAC [TX_INVARIANT_SOP_EOP_BD_CONSISTENT_SUM_BUFFER_LENGTH_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_IMP_TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED_WITH_PREVIOUS_FRAME_BDs_lemma = store_thm (
  "TX_INVARIANT_IMP_TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED_WITH_PREVIOUS_FRAME_BDs_lemma",
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH (tx_bd_queue nic) nic.regs.CPPI_RAM /\
    TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE nic /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW (tx_bd_queue nic) nic.regs.CPPI_RAM /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED_WITH_PREVIOUS_FRAME_BDs (tx_read_bd nic.tx.current_bd_pa nic.regs.CPPI_RAM) nic.tx``,
  GEN_TAC THEN
  REWRITE_TAC [TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED_WITH_PREVIOUS_FRAME_BDs_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE nic`` TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_def THEN
  KEEP_ASM_RW_ASM_TAC ``TX_STATE_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
  ASM_REWRITE_TAC [] THEN
  RW_ASM_TAC ``TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic`` TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_def THEN
  KEEP_ASM_RW_ASM_TAC ``TX_STATE_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_CURRENT_BD_PA_BD_QUEUE_lemma)))) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPECL [``nic.tx.current_bd_pa``, ``tx_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic.tx : tx_state``] TX_INVARIANT_BD_PA_IN_QUEUE_AND_SOP_EOP_MATCH_AND_NO_BUFFER_LENGTH_OVERFLOW_IMP_NOT_TX_BUFFER_LENGTH_OVERFLOW_lemma)) THEN
  ASM_REWRITE_TAC [] THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPECL [``nic.tx.current_bd_pa``, ``tx_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic.tx : tx_state``] TX_INVARIANT_BD_PA_IN_QUEUE_AND_SOP_EOP_MATCH_AND_CONSISTENT_SUM_BUFFER_LENGTH_IMP_TX_CONSISTENT_SUM_BUFFER_LENGTH_lemma)))) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED_DEPENDS_ONLY_ON_BD_lemma = store_thm (
  "TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED_DEPENDS_ONLY_ON_BD_lemma",
  ``BD_PROPERTY_DEPENDS_ONLY_ON_BD TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED``,
  REWRITE_TAC [BD_PROPERTY_DEPENDS_ONLY_ON_BD_def] THEN
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  MATCH_MP_ASM_IMP_TAC ``BD_EQ a m m'`` BD_EQ_IMP_TX_BD_EQ_lemma THEN
  ASM_REWRITE_TAC [TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED_def]);

val TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_IMP_TAIL_lemma = store_thm (
  "TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_IMP_TAIL_lemma",
  ``!h t CPPI_RAM.
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (h::t) CPPI_RAM
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED t CPPI_RAM``,
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_DEF] THEN
  REWRITE_TAC [boolTheory.AND2_THM]);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_WELL_DEFINED_IMP_BD_WELL_DEFINED_lemma = store_thm (
  "TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_WELL_DEFINED_IMP_BD_WELL_DEFINED_lemma",
  ``!bd_pa q CPPI_RAM.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED q CPPI_RAM
    ==>
    TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED (tx_read_bd bd_pa CPPI_RAM)``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  RW_ASM_TAC ``TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED bd_pa CPPI_RAM`` TX_INVARIANT_BD_CONFIGURATION_WELL_DEFINED_def THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_NOT_EMPTY_WELL_DEFINED_BD_QUEUE_CONFIGURATION_IMP_CURRENT_BD_WELL_DEFINED_CONFIGURATION_lemma = store_thm (
  "TX_INVARIANT_NOT_EMPTY_WELL_DEFINED_BD_QUEUE_CONFIGURATION_IMP_CURRENT_BD_WELL_DEFINED_CONFIGURATION_lemma",
  ``!nic.
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_CURRENT_BD_CONFIGURATION_WELL_DEFINED (tx_read_bd nic.tx.current_bd_pa nic.regs.CPPI_RAM)``,
  GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_MEM_CURRENT_BD_PA_BD_QUEUE_lemma)))) THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPECL [``nic.tx.current_bd_pa``, ``tx_bd_queue nic``, ``nic.regs.CPPI_RAM``] TX_INVARIANT_BD_PA_IN_QUEUE_AND_QUEUE_WELL_DEFINED_IMP_BD_WELL_DEFINED_lemma)))) THEN
  ASM_REWRITE_TAC []);

val TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma = store_thm (
  "TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma",
  ``!nic.
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic) nic.regs.CPPI_RAM``,
  GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_def] THEN
  REWRITE_TAC [TX_INVARIANT_COMPLETE_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => MATCH_MP_TAC thm) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_BD_PA_IN_QUEUE_AND_LINUX_SOP_EOP_MATCH_IMP_TX_INVARIANT_CURRENT_BD_lemma = store_thm (
  "TX_INVARIANT_BD_PA_IN_QUEUE_AND_LINUX_SOP_EOP_MATCH_IMP_TX_INVARIANT_CURRENT_BD_lemma",
  ``!bd_pa q CPPI_RAM.
    MEM bd_pa q /\
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH q CPPI_RAM
    ==>
    (tx_read_bd bd_pa CPPI_RAM).eop``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_QUEUE_SOP_EOP_MATCH_def] THEN
  REWRITE_TAC [TX_LINUX_BD_SOP_EOP_def] THEN
  REWRITE_TAC [TX_LINUX_BD_EOP_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC ``bd_pa : 32 word`` thm))) THEN
  ASM_REWRITE_TAC []);






  








(******************************************************************************
 ******************Non-modification lemmas*************************************
 ******************************************************************************
 The following is a sequence of lemmas stating: If certain state components of*
 two states are equal and one state satisfies a subpredicate of****************
 TX_INVARIANT_WELL_DEFINED, then the other state also satisfies the same*******
 subpredicate of TX_INVARIANT_WELL_DEFINED.************************************
 ******************************************************************************)
(*
 * TX_INVARIANT_NOT_DEAD:
 * -nic.dead
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_NOT_DEAD_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_NOT_DEAD_lemma",
  ``!nic nic'.
    (nic'.dead = nic.dead) /\
    TX_INVARIANT_NOT_DEAD nic
    ==>
    TX_INVARIANT_NOT_DEAD nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_NOT_DEAD_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_BD_QUEUE_FINITE:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_FINITE_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_FINITE_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_BD_QUEUE_FINITE nic
    ==>
    TX_INVARIANT_BD_QUEUE_FINITE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_FINITE_def, tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_BD_QUEUE_NO_OVERLAP:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_NO_OVERLAP_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_NO_OVERLAP_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_BD_QUEUE_NO_OVERLAP (tx_bd_queue nic)
    ==>
    TX_INVARIANT_BD_QUEUE_NO_OVERLAP (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [tx_bd_queue_def] THEN
  RW_ASM_TAC ``P`` tx_bd_queue_def THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_CURRENT_BD_PA_IN_QUEUE_STATE:
 * -nic.tx.current_bd_pa
 * -nic.tx.sop_bd_pa
 * -nic.tx.state
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic nic'.
    (nic'.tx.current_bd_pa = nic.tx.current_bd_pa) /\
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic
    ==>
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASM_RW_ASM_TAC ``TX_STATE_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
  REWRITE_TAC [NOT_TX_BD_QUEUE_EMPTY_def] THEN
  RW_ASM_TAC ``NOT_TX_BD_QUEUE_EMPTY nic`` NOT_TX_BD_QUEUE_EMPTY_def THEN
  REWRITE_TAC [tx_bd_queue_def] THEN
  RW_ASM_TAC ``tx_bd_queue nic <> []`` tx_bd_queue_def THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA:
 * -nic.tx.current_bd_pa
 * -nic.tx.sop_bd_pa
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA_lemma",
  ``!nic nic'.
    (nic'.tx.current_bd_pa = nic.tx.current_bd_pa) /\
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic
    ==>
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_lemma",
  ``!nic nic'.
    (nic'.tx.current_bd_pa = nic.tx.current_bd_pa) /\
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (tx_bd_queue nic)
    ==>
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_def, tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_NON_MODIFICATION_TX_EXPECTS_SOP_EQ_CURRENT_BD_SOP_lemma = prove (
  ``!nic nic'.
    (nic'.tx.current_bd_pa = nic.tx.current_bd_pa) /\
    (nic'.tx.expects_sop ⇔ nic.tx.expects_sop) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_EXPECTS_SOP_EQ_CURRENT_BD_SOP (tx_read_bd nic.tx.current_bd_pa nic.regs.CPPI_RAM) nic.tx
    ==>
    TX_EXPECTS_SOP_EQ_CURRENT_BD_SOP (tx_read_bd nic'.tx.current_bd_pa nic'.regs.CPPI_RAM) nic'.tx``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_EXPECTS_SOP_EQ_CURRENT_BD_SOP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP:
 * -nic.tx.expects_sop
 * -nic.tx.current_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_lemma",
  ``!nic nic'.
    (nic'.tx.current_bd_pa = nic.tx.current_bd_pa) /\
    (nic'.tx.expects_sop = nic.tx.expects_sop) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE nic
    ==>
    TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASM_RW_ASM_TAC ``TX_STATE_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
  ASSUME_TAC (UNDISCH_ALL (hd (IMP_CANON (SPEC_ALL TX_NON_MODIFICATION_TX_EXPECTS_SOP_EQ_CURRENT_BD_SOP_lemma)))) THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

(*
 * TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED:
 * -nic.tx.sop_bd_pa
 * -nic.regs.CPPI_RAM
 *)
val TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic) nic.regs.CPPI_RAM
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [tx_bd_queue_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_NON_MODIFICATION_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_def] THEN
  REWRITE_TAC [TX_INVARIANT_COMPLETE_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  REWRITE_TAC [TX_INVARIANT_TAIL_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  WEAKEN_TAC is_imp THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL EQ_SOP_BD_PA_AND_CPPI_RAM_AND_TX_INVARIANT_BD_QUEUE_FINITE_IMP_EQ_BD_QUEUES_lemma)) THEN
  Cases_on `TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic'` THENL
  [
   ASSUME_TAC (UNDISCH (SPEC ``nic' : nic_state`` TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_NOT_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   REWRITE_TAC [combinTheory.o_DEF] THEN
   BETA_TAC THEN
   ASSUME_TAC (UNDISCH (SPEC ``nic' : nic_state`` NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma)) THEN
   ASM_REWRITE_TAC [] THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma)) THEN
   PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
   ASM_REWRITE_TAC [listTheory.TL] THEN
   ASM_RW_ASM_TAC ``q = h::t`` ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic) nic.regs.CPPI_RAM`` THEN
   RW_ASM_TAC ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (nic.tx.sop_bd_pa::t) nic.regs.CPPI_RAM`` TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def THEN
   RW_ASM_TAC ``EVERY f l`` listTheory.EVERY_DEF THEN
   ASM_REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def]
  ]);

val TX_NON_MODIFICATION_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma = store_thm (
  "TX_NON_MODIFICATION_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma",
  ``!nic nic'.
    (nic'.tx.sop_bd_pa = nic.tx.sop_bd_pa) /\
    (nic'.regs.CPPI_RAM = nic.regs.CPPI_RAM) /\
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic /\
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic' /\
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic /\
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_def] THEN
  REWRITE_TAC [TX_INVARIANT_COMPLETE_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  REWRITE_TAC [TX_INVARIANT_TAIL_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  WEAKEN_TAC is_imp THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL EQ_SOP_BD_PA_AND_CPPI_RAM_AND_TX_INVARIANT_BD_QUEUE_FINITE_IMP_EQ_BD_QUEUES_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC ``nic' : nic_state`` TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma)) THEN
  ASM_REWRITE_TAC [] THEN
  REWRITE_TAC [combinTheory.o_DEF] THEN
  BETA_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma)) THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASM_REWRITE_TAC [listTheory.TL] THEN
  RW_ASM_TAC ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED q m`` combinTheory.o_DEF THEN
  RW_ASM_TAC ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED q m`` (BETA_CONV ``(λx. TL (tx_bd_queue x)) nic``) THEN
  ASM_RW_ASM_TAC ``q = h::t`` ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED q m`` THEN
  RW_ASM_TAC ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED q m`` listTheory.TL THEN
  ASM_REWRITE_TAC []);

(******************************************************************************
 ****************End of invariant predicate non modification transfer lemmas.**
 ******************************************************************************)

val TX_INVARIANT_BD_QUEUE_FINITE_EQ_TX_BDs_IMP_EQ_TX_BD_QUEUEs_lemma = store_thm (
  "TX_INVARIANT_BD_QUEUE_FINITE_EQ_TX_BDs_IMP_EQ_TX_BD_QUEUEs_lemma",
  ``!nic nic'.
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    (nic'.tx = nic.tx) /\
    EQ_BDs (tx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    (tx_bd_queue nic' = tx_bd_queue nic)``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_FINITE_EQ_BD_QUEUE_TX_BD_QUEUE_lemma] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  MATCH_MP_TAC TX_BD_QUEUE_EQ_TX_STATE_EQ_TX_BD_QUEUE_BDs_IMP_EQ_TX_BD_QUEUEs_lemma THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_WELL_DEFINED_IMP_NOT_DEAD_lemma = store_thm (
  "TX_INVARIANT_WELL_DEFINED_IMP_NOT_DEAD_lemma",
  ``!nic.
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    ~nic.dead``,
  GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  REWRITE_TAC [TX_INVARIANT_NOT_DEAD_def] THEN
  REWRITE_TAC [boolTheory.AND1_THM]);

val _ = export_theory();

