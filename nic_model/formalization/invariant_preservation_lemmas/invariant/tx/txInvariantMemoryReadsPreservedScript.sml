open HolKernel Parse boolLib bossLib;
open helperTactics;
open txInvariantMemoryReadsTheory;
open tx_invariant_well_defined_lemmasTheory;
open bd_listTheory;
open tx_bd_queueTheory;
open tx_state_lemmasTheory;
open txInvariantTheory;
open txInvariantWellDefinedPreservedTheory;
open txInvariantWellDefinedTheory;

val _ = new_theory "txInvariantMemoryReadsPreserved";

val TX_INVARIANT_MEMORY_READABLE_BD_QUEUE_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_READABLE_BD_QUEUE_PRESERVED_lemma",
  ``!nic nic' READABLE.
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_MEMORY_READABLE_BD_QUEUE (tx_bd_queue nic) READABLE nic.regs.CPPI_RAM /\
    (nic'.tx = nic.tx) /\
    EQ_BDs (tx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    TX_INVARIANT_MEMORY_READABLE_BD_QUEUE (tx_bd_queue nic') READABLE nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_READABLE_BD_QUEUE_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_BD_QUEUE_FINITE_EQ_TX_BDs_IMP_EQ_TX_BD_QUEUEs_lemma)) THEN
  ASM_RW_ASM_TAC ``tx_bd_queue nic' = tx_bd_queue nic`` ``MEM e q`` THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC_ALL thm))) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPECL [``e : bd_pa_type``, ``tx_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] MEM_EQ_BDs_Q_IMP_BD_EQ_lemma)) THEN
  ASSUME_TAC (SYM (CONJ_ANT_TO_HYP (SPECL [``e : bd_pa_type``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] BD_EQ_IMP_TX_BD_EQ_lemma))) THEN
  RW_ASM_TAC ``TX_INVARIANT_MEMORY_READABLE_BD a m r`` TX_INVARIANT_MEMORY_READABLE_BD_def THEN
  ASM_REWRITE_TAC [TX_INVARIANT_MEMORY_READABLE_BD_def]);

val TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE_PRESERVED_lemma",
  ``!nic nic' READABLE.
    TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE nic /\
    (nic'.tx = nic.tx)
    ==>
    TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_EQ_IMP_TX_STATE_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma))) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE_PRESERVED_lemma",
  ``!nic nic'.
    TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE nic /\
    (nic'.tx = nic.tx)
    ==>
    TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE_def] THEN
  DISCH_TAC THEN
DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_EQ_IMP_TX_STATE_EQ_lemma)) THEN
  PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val imp1 = CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma)) in
    let val imp2 = CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_PROCESS_MEMORY_READ_REPLY_DEP_lemma)) in
    let val thm = DISJ_CASES_UNION thm imp1 imp2 in
      ASSUME_TAC thm
    end end end) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_MEMORY_READABLE_STATE_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_READABLE_STATE_PRESERVED_lemma",
  ``!nic nic' READABLE.
    TX_INVARIANT_MEMORY_READABLE_STATE nic READABLE /\
    (nic'.tx = nic.tx)
    ==>
    TX_INVARIANT_MEMORY_READABLE_STATE nic' READABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_READABLE_STATE_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_EQ_IMP_TX_STATE_EQ_lemma)) THEN
  Cases_on `TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic'` THENL
  [
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic`` ``P ==> Q`` THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q`` THEN
   SPLIT_ASM_TAC THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_PROCESS_MEMORY_READ_REPLY_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``TX_STATE_PROCESS_MEMORY_READ_REPLY nic`` ``P ==> Q`` THEN
   KEEP_ASM_RW_ASM_TAC ``nic'.tx = (nic : nic_state).tx`` ``nic'.tx.number_of_buffer_bytes_left_to_request >+ 0w`` THEN
   ASM_RW_ASM_TAC ``nic.tx.number_of_buffer_bytes_left_to_request >+ 0w`` ``P ==> Q`` THEN
   ASM_REWRITE_TAC []
  ]);

val TX_INVARIANT_MEMORY_READABLE_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_READABLE_PRESERVED_lemma",
  ``!nic nic' READABLE.
    TX_INVARIANT_BD_QUEUE_FINITE nic /\
    TX_INVARIANT_MEMORY_READABLE nic READABLE /\
    (nic'.tx = nic.tx) /\
    EQ_BDs (tx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    TX_INVARIANT_MEMORY_READABLE nic' READABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_READABLE_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_MEMORY_READABLE_BD_QUEUE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_STATE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_MEMORY_BYTES_LEFT_TO_REQUEST_IMP_NO_OVERFLOW_STATE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_MEMORY_READABLE_STATE_PRESERVED_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_INVARIANT_MEMORY_PRESERVED_lemma = store_thm (
  "TX_INVARIANT_MEMORY_PRESERVED_lemma",
  ``!nic nic' READABLE.
    TX_INVARIANT_MEMORY nic READABLE /\
    (nic'.dead = nic.dead) /\
    (nic'.tx = nic.tx) /\
    EQ_BDs (tx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    TX_INVARIANT_MEMORY nic' READABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_MEMORY_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_WELL_DEFINED_PRESERVED_lemma)) THEN
  RW_ASM_TAC ``TX_INVARIANT_WELL_DEFINED nic`` TX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_MEMORY_READABLE_PRESERVED_lemma)) THEN
  ASM_REWRITE_TAC []);

val _ = export_theory();

