open HolKernel Parse boolLib bossLib;
open rxInvariantWellDefinedTheory;
open rx_state_definitionsTheory;
open rx_state_lemmasTheory;
open rx_transition_definitionsTheory;

val _ = new_theory "rxInvariantWellDefinedRX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT2_lemmas";

(* This lemma is useful for transition functions returning a state in which the
   reception automaton is not in the idle state nor in the write_cp state. *)
val NOT_RX_STATE_IDLE_AND_NOT_RX_STATE_WRITE_CP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma = store_thm (
  "NOT_RX_STATE_IDLE_AND_NOT_RX_STATE_WRITE_CP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma",
  ``!nic.
    ~RX_STATE_IDLE nic /\
    ~RX_STATE_WRITE_CP nic
    ==>
    RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic``,
  GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma = store_thm (
  "RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma",
  ``!nic.
    RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM nic
    ==>
    RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  MATCH_MP_TAC NOT_RX_STATE_IDLE_AND_NOT_RX_STATE_WRITE_CP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma THEN
  MATCH_MP_TAC RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_NOT_RX_STATE_IDLE_AND_NOT_RX_STATE_WRITE_CP_lemma THEN
  ASM_REWRITE_TAC []);

(* Given a theorem of a state definition, e.g. RX_STATE_FETCH_NEXT_BD_def,
   stores a theorem of the form:
   RX_STATE_FETCH_NEXT_BD nic
   ==>
   RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic

   Invoked as follows:
   store_thm_rx_state_fetch_issue_write RX_STATE_FETCH_NEXT_BD_def "name_of_stored_theorem".
 *)
fun store_thm_rx_state_fetch_issue_write (STATE : thm) (name : string) =
  let val RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_NON_STATE_DEFINITIONS =
  [RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_def,
   RX_STATE_WRITE_CPPI_RAM_def, RX_STATE_WRITE_CPPI_RAM_AND_NOT_WRITE_RX_SOP_BD_PA_def,
   RX_STATE_WRITE_CURRENT_BD_PA_def, 
   RX_STATE_WRITE_EOP_OR_EOP_SOP_def, RX_STATE_WRITE_EOP_def,
   RX_STATE_WRITE_EOP_SOP_def, 
   RX_STATE_WRITE_SOP_AND_NOT_WRITE_RX_SOP_BD_PA_def,
   RX_STATE_WRITE_SOP_EOP_AND_WRITE_RX_SOP_BD_PA_def]
      val ant = (#1 o dest_eq o #2 o dest_forall o concl) STATE
      val suc = (#1 o dest_eq o concl) (SPEC ``nic : nic_state`` RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_def)
      val state_imp_tm = mk_forall (``nic : nic_state``, mk_imp (ant, suc))
      val STATE_IMP_FETCH_ISSUE_WRITE_lemma = prove (state_imp_tm,
        GEN_TAC THEN
        REWRITE_TAC RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_NON_STATE_DEFINITIONS THEN
        DISCH_TAC THEN
        ASM_REWRITE_TAC [])
      val goal_suc = (#1 o dest_eq o #2 o dest_forall o concl) RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_def
      val goal = mk_forall (``nic : nic_state``, mk_imp (ant, goal_suc))
      val tactic =
        GEN_TAC THEN
        DISCH_TAC THEN
        MATCH_MP_TAC RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma THEN
        MATCH_MP_TAC STATE_IMP_FETCH_ISSUE_WRITE_lemma THEN
        ASM_REWRITE_TAC []
  in
  store_thm (name, goal, tactic)
  end;

(*
   RX_STATE_FETCH_NEXT_BD nic
   ==>
   RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic
 *)
val RX_STATE_FETCH_NEXT_BD_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_FETCH_NEXT_BD_def "RX_STATE_FETCH_NEXT_BD_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_ISSUE_NEXT_MEMORY_WRITE_REQUEST_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_ISSUE_NEXT_MEMORY_WRITE_REQUEST_def "RX_STATE_ISSUE_NEXT_MEMORY_WRITE_REQUEST_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_PACKET_ERROR_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_PACKET_ERROR_def "RX_STATE_WRITE_PACKET_ERROR_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_RX_VLAN_ENCAP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_RX_VLAN_ENCAP_def "RX_STATE_WRITE_RX_VLAN_ENCAP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_FROM_PORT_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_FROM_PORT_def "RX_STATE_WRITE_FROM_PORT_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_EOP_BUFFER_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_EOP_BUFFER_LENGTH_def "RX_STATE_WRITE_EOP_BUFFER_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_SET_EOP_EOP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_SET_EOP_EOP_def "RX_STATE_SET_EOP_EOP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_SET_EOP_EOQ_OR_WRITE_SOP_BUFFER_OFFSET_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_SET_EOP_EOQ_OR_WRITE_SOP_BUFFER_OFFSET_def "RX_STATE_SET_EOP_EOQ_OR_WRITE_SOP_BUFFER_OFFSET_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_BUFFER_OFFSET_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_BUFFER_OFFSET_def "RX_STATE_WRITE_SOP_BUFFER_OFFSET_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_BUFFER_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_BUFFER_LENGTH_def "RX_STATE_WRITE_SOP_BUFFER_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_SET_SOP_SOP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_SET_SOP_SOP_def "RX_STATE_SET_SOP_SOP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_PASS_CRC_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_PASS_CRC_def "RX_STATE_WRITE_SOP_PASS_CRC_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_LONG_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_LONG_def "RX_STATE_WRITE_SOP_LONG_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_SHORT_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_SHORT_def "RX_STATE_WRITE_SOP_SHORT_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_MAC_CTL_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_MAC_CTL_def "RX_STATE_WRITE_SOP_MAC_CTL_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_WRITE_SOP_PACKET_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_WRITE_SOP_PACKET_LENGTH_def "RX_STATE_WRITE_SOP_PACKET_LENGTH_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val RX_STATE_SET_SOP_EOP_OVERRUN_OR_CLEAR_SOP_OWNER_AND_HDP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_SET_SOP_EOP_OVERRUN_OR_CLEAR_SOP_OWNER_AND_HDP_def "RX_STATE_SET_SOP_EOP_OVERRUN_OR_CLEAR_SOP_OWNER_AND_HDP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

(*
   RX_STATE_CLEAR_SOP_OWNER_AND_HDP nic
   ==>
   RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic
 *)
val RX_STATE_CLEAR_SOP_OWNER_AND_HDP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma =
  store_thm_rx_state_fetch_issue_write RX_STATE_CLEAR_SOP_OWNER_AND_HDP_def "RX_STATE_CLEAR_SOP_OWNER_AND_HDP_IMP_BD_QUEUE_STRUCTURE_SUPPORT2_lemma";

val _ = export_theory();

