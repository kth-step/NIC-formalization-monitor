open HolKernel Parse boolLib bossLib;
open helperTactics;
open rxInvariantWellDefinedTheory;
open bd_queue_preservation_lemmasTheory;
open rx_bd_queueTheory;
open rxInvariantWellDefinedLemmasTheory;
open rx_state_lemmasTheory;
open bd_listTheory;
open bdTheory;
open it_state_lemmasTheory;

val _ = new_theory "rxInvariantWellDefinedPreserved";

val RX_INVARIANT_BD_QUEUE_FINITE_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_FINITE_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_FINITE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_BD_QUEUE_FINITE_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  EXISTS_TAC ``q : bd_pa_type list`` THEN
  MATCH_MP_TAC BD_QUEUE_EQ_BDs_IMP_BD_QUEUE_lemma THEN
  EXISTS_TAC ``nic.regs.CPPI_RAM`` THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_BD_QUEUE_IMP_rx_bd_queue_lemma)) THEN
  ASM_RW_ASM_TAC ``rx_bd_queue nic = q`` ``EQ_BDs q m m'`` THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_BD_QUEUE_STRUCTURE_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_STRUCTURE_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_BD_QUEUE_STRUCTURE nic /\
    RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT nic /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_STRUCTURE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_BD_QUEUE_STRUCTURE_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_SUBINVARIANT_IMP_EQ_RX_UNSEEN_BD_QUEUE_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA nic /\
    RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE nic /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_ISSUE_NEXT_MEMORY_WRITE_REQUEST_OR_WRITE_CPPI_RAM_DEP_lemma))) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  RW_ASM_TAC ``RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE nic`` RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_def THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_ISSUE_NEXT_MEMORY_WRITE_REQUEST_OR_WRITE_CPPI_RAM_IMP_RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_lemma)) THEN
  ASM_RW_ASM_TAC ``RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM nic`` ``P ==> Q`` THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPECL [``nic.rx.current_bd_pa``, ``rx_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] MEM_EQ_BDs_Q_IMP_READ_NDP_EQ_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic /\
    (nic'.it.state = nic.it.state) /\
    (nic'.rx = nic.rx)
    ==>
    RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  Cases_on `RX_STATE_IDLE nic' âˆ§ IT_STATE_INITIALIZED nic'` THENL
  [
   SPLIT_ASM_TAC THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_IDLE_DEP_lemma))) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] IT_STATE_INITIALIZED_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``RX_STATE_IDLE nic`` ``P ==> Q`` THEN
   ASM_RW_ASM_TAC ``IT_STATE_INITIALIZED nic`` ``P ==> Q`` THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_SOP_BD_PA_EQ_lemma)) THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q`` THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_WRITE_CP_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``RX_STATE_WRITE_CP nic`` ``P ==> Q`` THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_SOP_BD_PA_EQ_lemma)) THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
   ASM_REWRITE_TAC []
  ]);

val RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP nic /\
    (nic'.rx = nic.rx)
    ==>
    RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_WRITE_CP_DEP_lemma))) THEN
  ASM_RW_ASM_TAC ``RX_STATE_WRITE_CP nic`` ``P ==> Q`` THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_NDP_EQ_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE nic /\
    (nic'.it.state = nic.it.state) /\
    (nic'.rx = nic.rx) /\
    (nic'.rd.state = nic.rd.state) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  Cases_on `RX_STATE_RECEIVE_FRAME nic'` THENL
  [
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_SOP_BD_PA_EQ_lemma)) THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_RECEIVE_FRAME_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``RX_STATE_RECEIVE_FRAME nic`` ``P ==> Q`` THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  Cases_on `RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM nic'` THENL
  [
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_DEP_lemma))) THEN
   ASM_RW_ASM_TAC ``RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM nic`` ``P ==> Q`` THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_SOP_BD_PA_EQ_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_WRITE_CP_NOT_BD_QUEUE_EMPTY_DEP_lemma))) THEN
  ASM_RW_ASM_TAC ``RX_STATE_WRITE_CP_NOT_BD_QUEUE_EMPTY nic`` ``P ==> Q`` THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA nic /\
    (nic'.rx = nic.rx)
    ==>
    RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_STATE_EQ_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] RX_STATE_WRITE_CPPI_RAM_POST_PROCESS_DEP_lemma))) THEN
  ASM_RW_ASM_TAC ``RX_STATE_WRITE_CPPI_RAM_POST_PROCESS nic`` ``P ==> Q`` THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_CURRENT_BD_PA_EQ_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_EQ_IMP_RX_EOP_BD_PA_EQ_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT nic /\
    (nic'.it.state = nic.it.state) /\
    (nic'.rx = nic.rx) /\
    (nic'.rd.state = nic.rd.state) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_STATE_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_IMP_CURRENT_BD_NDP_EQ_NDP_CURRENT_BD_PA_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_write_cp_IMP_CURRENT_BD_PA_EQ_CURRENT_BD_NDP_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_STATE_WRITE_CPPI_RAM_POST_PROCESS_IMP_EOP_EQ_CURRENT_BD_PA_PRESERVED_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_BD_QUEUE_NO_OVERLAP_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_NO_OVERLAP_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_BD_QUEUE_NO_OVERLAP (rx_bd_queue nic) /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_NO_OVERLAP (rx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (rx_bd_queue nic) /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (rx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_EQ_RX_STATE_EQ_RX_BD_QUEUE_BDs_IMP_EQ_RX_BD_QUEUEs_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_BD_QUEUE_WELL_DEFINED_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_BD_QUEUE_WELL_DEFINED_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_BD_QUEUE_FINITE nic /\
    RX_INVARIANT_BD_QUEUE_STRUCTURE nic /\
    RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT nic /\
    RX_INVARIANT_BD_QUEUE_WELL_DEFINED (rx_unseen_bd_queue nic) nic.regs.CPPI_RAM /\
    (nic'.rx = nic.rx) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM
    ==>
    RX_INVARIANT_BD_QUEUE_WELL_DEFINED (rx_unseen_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_BD_QUEUE_WELL_DEFINED_def] THEN
  REWRITE_TAC [listTheory.EVERY_MEM] THEN
  BETA_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  GEN_TAC THEN
  DISCH_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_SUBINVARIANT_IMP_EQ_RX_UNSEEN_BD_QUEUE_lemma)) THEN
  ASM_RW_ASM_TAC ``rx_unseen_bd_queue nic' = rx_unseen_bd_queue nic`` ``MEM e q`` THEN
  PAT_ASSUM ``!x.P`` (fn thm => ASSUME_TAC (UNDISCH (SPEC_ALL thm))) THEN
  RW_ASM_TAC ``RX_INVARIANT_BD_QUEUE_STRUCTURE nic`` RX_INVARIANT_BD_QUEUE_STRUCTURE_def THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASM_RW_ASM_TAC ``q = q' ++ q''`` ``EQ_BDs q m m'`` THEN
  ASSUME_TAC (UNDISCH (SPECL [``rx_seen_bd_queue : bd_pa_type list``, ``rx_unseen_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] EQ_BDs_IMP_EQ_SUFFIX_BDs_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPECL [``e : bd_pa_type``, ``rx_unseen_bd_queue nic``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] MEM_EQ_BDs_Q_IMP_BD_EQ_lemma)) THEN
  ASSUME_TAC (SYM (CONJ_ANT_TO_HYP (SPECL [``e : bd_pa_type``, ``nic.regs.CPPI_RAM``, ``nic'.regs.CPPI_RAM``] BD_EQ_IMP_rx_read_bd_EQ_lemma))) THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_RX_BUFFER_OFFSET_ZERO_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_RX_BUFFER_OFFSET_ZERO_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_RX_BUFFER_OFFSET_ZERO nic /\
    (nic'.regs.RX_BUFFER_OFFSET = nic.regs.RX_BUFFER_OFFSET)
    ==>
    RX_INVARIANT_RX_BUFFER_OFFSET_ZERO nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_RX_BUFFER_OFFSET_ZERO_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val RX_INVARIANT_WELL_DEFINED_PRESERVED_lemma = store_thm (
  "RX_INVARIANT_WELL_DEFINED_PRESERVED_lemma",
  ``!nic nic'.
    RX_INVARIANT_WELL_DEFINED nic /\
    (nic'.dead = nic.dead) /\
    (nic'.it.state = nic.it.state) /\
    (nic'.rx = nic.rx) /\
    (nic'.rd.state = nic.rd.state) /\
    EQ_BDs (rx_bd_queue nic) nic.regs.CPPI_RAM nic'.regs.CPPI_RAM /\
    (nic'.regs.RX_BUFFER_OFFSET = nic.regs.RX_BUFFER_OFFSET)
    ==>
    RX_INVARIANT_WELL_DEFINED nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_WELL_DEFINED_def] THEN
  REWRITE_TAC [RX_INVARIANT_NOT_DEAD_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_FINITE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_STRUCTURE_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_NO_OVERLAP_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_BD_QUEUE_WELL_DEFINED_PRESERVED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_INVARIANT_RX_BUFFER_OFFSET_ZERO_PRESERVED_lemma)) THEN
  ASM_REWRITE_TAC []);

val _ = export_theory();

