open HolKernel Parse boolLib bossLib;
open helperTactics;
open tx_1fetch_next_bd_lemmasTheory;
open txInvariantWellDefinedTheory;
open tx_invariant_well_defined_lemmasTheory;
open tx_state_lemmasTheory;
open tx_bd_queueTheory;

(*
 * This file contains lemmas and a theorem of that the fetch_next_bd transition
 * function preserves the well defined transmission invariant.
 *)

val _ = new_theory "tx_1fetch_next_bd";

val TX_fetch_next_bd_PRESERVES_NOT_DEAD_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_NOT_DEAD nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_INVARIANT_WELL_DEFINED_IMP_BD_WELL_DEFINED_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_NOT_DEAD_lemma)) THEN
  RW_ASM_TAC ``TX_INVARIANT_WELL_DEFINED nic`` TX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``TX_INVARIANT_NOT_DEAD nic`` TX_INVARIANT_NOT_DEAD_def THEN
  ASM_REWRITE_TAC [TX_INVARIANT_NOT_DEAD_def]);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_BD_QUEUE_FINITE_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_BD_QUEUE_FINITE nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  RW_ASM_TAC ``TX_INVARIANT_WELL_DEFINED nic`` TX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_FINITE_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_BD_QUEUE_NO_OVERLAP_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_BD_QUEUE_NO_OVERLAP (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_NO_OVERLAP_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_BD_QUEUE_SOP_EOP_MATCH_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_SOP_EOP_MATCH_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)

val TX_fetch_next_bd_PRESERVES_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_CURRENT_BD_PA_EQ_SOP_BD_PA_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_CURRENT_BD_PA_EQ_SOP_BD_PA_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_BD_QUEUE_LOCATION_DEFINED_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)


val TX_fetch_next_bd_PRESERVES_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH (tx_bd_queue nic') nic'.regs.CPPI_RAM``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NON_MODIFICATION_TX_INVARIANT_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_lemma)) THEN
  ASM_REWRITE_TAC []);


(*****************************************)



val TX_fetch_next_bd_PRESERVES_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  REWRITE_TAC [TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_def] THEN
  REWRITE_TAC [TX_INVARIANT_COMPLETE_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  REWRITE_TAC [TX_INVARIANT_TAIL_BD_QUEUE_CONFIGURATION_WELL_DEFINED_def] THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_1fetch_next_bd_IMP_NEXT_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC ``nic' : nic_state`` TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma)) THEN
  PAT_ASSUM ``TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic'`` (fn thm => REWRITE_TAC [thm]) THEN
  PAT_ASSUM ``~TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic'`` (fn thm => REWRITE_TAC [thm]) THEN
  RW_ASM_TAC ``TX_INVARIANT_WELL_DEFINED nic`` TX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_NOT_BD_QUEUE_EMPTY_IMP_SOP_BD_PA_HEAD_BD_QUEUE_lemma)) THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_fetch_next_bd_NON_MODIFICATION_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL EQ_SOP_BD_PA_AND_CPPI_RAM_AND_TX_INVARIANT_BD_QUEUE_FINITE_IMP_EQ_BD_QUEUES_lemma)) THEN
  KEEP_ASM_RW_ASM_TAC ``tx_bd_queue nic = nic.tx.sop_bd_pa::t`` ``TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED (tx_bd_queue nic) nic.regs.CPPI_RAM`` THEN
  REWRITE_TAC [combinTheory.o_DEF] THEN
  BETA_TAC THEN
  ASM_REWRITE_TAC [listTheory.TL] THEN
  MATCH_MP_TAC TX_INVARIANT_BD_QUEUE_CONFIGURATION_WELL_DEFINED_IMP_TAIL_lemma THEN
  EXISTS_TAC ``nic.tx.sop_bd_pa`` THEN
  ASM_REWRITE_TAC []);








(*********************************************************)





val TX_fetch_next_bd_PRESERVES_TX_INVARIANT_CURRENT_BD_STATE_lemma = prove (
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic' = tx_1fetch_next_bd nic) /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_CURRENT_BD_STATE nic'``,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  REWRITE_TAC [TX_INVARIANT_CURRENT_BD_STATE_def] THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_AND_TX_INVARIANT_WELL_DEFINED_IMP_CURRENT_BD_EOP_STATE_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_TX_INVARIANT_CURRENT_BD_NONZERO_NDP_EQ_CURRENT_BD_PA_NDP_STATE_lemma)) THEN
  ASM_REWRITE_TAC []);





(********************************************************************************)
(******************INVARIANT_PRESERVED_BY_FETCH_NEXT_BD**************************)
(********************************************************************************)

val TX_fetch_next_bd_PRESERVES_TX_INVARIANT_WELL_DEFINED_lemma = store_thm (
  "TX_fetch_next_bd_PRESERVES_TX_INVARIANT_WELL_DEFINED_lemma",
  ``!nic nic'.
    (nic' = tx_1fetch_next_bd nic) /\
    TX_STATE_FETCH_NEXT_BD nic /\
    TX_INVARIANT_WELL_DEFINED nic
    ==>
    TX_INVARIANT_WELL_DEFINED nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_NOT_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_BD_QUEUE_FINITE_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_BD_QUEUE_NO_OVERLAP_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_BD_QUEUE_SOP_EOP_MATCH_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_CURRENT_BD_PA_EQ_SOP_BD_PA_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_BD_QUEUE_LOCATION_DEFINED_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_EXPECTS_SOP_EQ_CURRENT_BD_PA_SOP_STATE_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_SOP_EOP_BD_QUEUE_NO_BUFFER_LENGTH_OVERFLOW_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_SOP_EOP_BD_QUEUE_CONSISTENT_SUM_BUFFER_LENGTH_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_BD_QUEUE_CONFIGURATION_WELL_DEFINED_STATE_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_fetch_next_bd_PRESERVES_TX_INVARIANT_CURRENT_BD_STATE_lemma)) THEN
  ASM_REWRITE_TAC [TX_INVARIANT_WELL_DEFINED_def]);

val _ = export_theory();

