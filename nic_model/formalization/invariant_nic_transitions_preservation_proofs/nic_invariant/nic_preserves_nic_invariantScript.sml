open HolKernel Parse boolLib bossLib;
open helperTactics;
open nic_transition_lemmasTheory;
open nicInvariantTheory;

val _ = new_theory "nic_preserves_nic_invariant";

val NIC_REGISTER_READ_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "NIC_REGISTER_READ_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env pa nic' value' READABLE WRITABLE.
    NIC_REGISTER_READ_TRANSITION nic env pa nic' value' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL NIC_REGISTER_READ_TRANSITION_ID_lemma)) THEN
  ASM_REWRITE_TAC []);

val IT_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "IT_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic nic' READABLE WRITABLE.
    IT_AUTONOMOUS_TRANSITION nic nic' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL it_transition_lemmasTheory.IT_AUTONOMOUS_TRANSITION_NON_MODIFICATION_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL it_preserves_qd_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL it_preserves_it_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL it_preserves_tx_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL it_preserves_rx_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL it_preserves_td_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL it_preserves_rd_invariantTheory.IT_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_AUTONOMOUS_TRANSITION_TX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma = store_thm (
  "TX_AUTONOMOUS_TRANSITION_TX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma",
  ``!nic env nic' mr' READABLE.
    TX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    TX_INVARIANT nic READABLE
    ==>
    ~nic'.dead``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [txInvariantTheory.TX_INVARIANT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL tx_transition_lemmasTheory.TX_AUTONOMOUS_TRANSITION_IMP_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_lemma)) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  RW_ASM_TAC ``TX_INVARIANT_MEMORY nic READABLE`` txInvariantTheory.TX_INVARIANT_MEMORY_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``TX_AUTONOMOUS_TRANSITION nic env nic' mr'`` tx_transition_definitionsTheory.TX_AUTONOMOUS_TRANSITION_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_transition_preserves_tx_invariant_well_definedTheory.tx_transition_PRESERVES_TX_INVARIANT_WELL_DEFINED_lemma)) THEN
  RW_ASM_TAC ``TX_INVARIANT_WELL_DEFINED nic'`` txInvariantWellDefinedTheory.TX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``TX_INVARIANT_NOT_DEAD nic'`` txInvariantWellDefinedTheory.TX_INVARIANT_NOT_DEAD_def THEN
  ASM_REWRITE_TAC []);

val TX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "TX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env nic' mr' READABLE WRITABLE.
    TX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_AUTONOMOUS_TRANSITION_TX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_qd_invariantTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_it_invariantTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_transition_preserves_tx_invariant_memory_and_only_reads_readable_memoryTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_rx_invariantTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_td_invariantTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_rd_invariantTheory.TX_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_RX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_RX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma",
  ``!nic env nic' mr' WRITABLE.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    RX_INVARIANT nic WRITABLE
    ==>
    ~nic'.dead``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [rxInvariantTheory.RX_INVARIANT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL rx_transition_lemmasTheory.RX_AUTONOMOUS_TRANSITION_IMP_RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma)) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  RW_ASM_TAC ``RX_INVARIANT_MEMORY nic WRITABLE`` rxInvariantTheory.RX_INVARIANT_MEMORY_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``RX_AUTONOMOUS_TRANSITION nic env nic' mr'`` rx_transition_definitionsTheory.RX_AUTONOMOUS_TRANSITION_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_transition_preserves_rx_invariant_well_definedTheory.rx_transition_PRESERVES_RX_INVARIANT_WELL_DEFINED_lemma)) THEN
  RW_ASM_TAC ``RX_INVARIANT_WELL_DEFINED nic'`` rxInvariantWellDefinedTheory.RX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``RX_INVARIANT_NOT_DEAD nic'`` rxInvariantWellDefinedTheory.RX_INVARIANT_NOT_DEAD_def THEN
  ASM_REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env nic' mr' READABLE WRITABLE.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_RX_INVARIANT_IMP_NOT_NEXT_STATE_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_preserves_qd_invariantTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_preserves_it_invariantTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_preserves_tx_invariantTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_transition_preserves_rx_invariant_and_only_writes_writable_memoryTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_preserves_td_invariantTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_preserves_rd_invariantTheory.RX_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val TD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "TD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env nic' READABLE WRITABLE.
    TD_AUTONOMOUS_TRANSITION nic env nic' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_transition_lemmasTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_qd_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_it_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_tx_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_rx_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_td_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL td_preserves_rd_invariantTheory.TD_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val RD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "RD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env nic' READABLE WRITABLE.
    RD_AUTONOMOUS_TRANSITION nic env nic' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_transition_lemmasTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_qd_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_it_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_tx_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_rx_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_td_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rd_preserves_rd_invariantTheory.RD_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val NIC_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "NIC_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic env nic' mr' int' READABLE WRITABLE.
    NIC_AUTONOMOUS_TRANSITION nic env nic' mr' int' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL NIC_AUTONOMOUS_TRANSITION_CASEs_lemma)) THEN
  REPEAT (PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val disjunct = (#1 o dest_disj o concl) thm in
    let fun tactic lemma = MATCH_MP_TAC (SPEC_ALL lemma) THEN ASM_REWRITE_TAC [] THEN NO_TAC in
    let val lemmas = [IT_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma,
                      TX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma,
                      RX_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma,
                      TD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma,
                      RD_AUTONOMOUS_TRANSITION_PRESERVES_NIC_INVARIANT_lemma] in
      ASM_CASES_TAC disjunct THENL
      [
       FIRST (map tactic lemmas)
       ,
       ASSUME_TAC thm THEN
       ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
      ]
    end end end)) THEN
  ASM_REWRITE_TAC []);

val NIC_MEMORY_READ_REPLY_TRANSITION_PRESERVES_NIC_INVARIANT_lemma = store_thm (
  "NIC_MEMORY_READ_REPLY_TRANSITION_PRESERVES_NIC_INVARIANT_lemma",
  ``!nic mr nic' READABLE WRITABLE.
    NIC_MEMORY_READ_REPLY_TRANSITION nic mr nic' /\
    NIC_INVARIANT nic READABLE WRITABLE
    ==>
    NIC_INVARIANT nic' READABLE WRITABLE``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [NIC_STATE_DEFINED_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL NIC_MEMORY_READ_REPLY_TRANSITION_IMP_TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_transition_lemmasTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_DEAD_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_qd_invariantTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_QD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_it_invariantTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_IT_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_transition_preserves_tx_invariant_memory_and_only_reads_readable_memoryTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_TX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_rx_invariantTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_RX_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_td_invariantTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_TD_INVARIANT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_preserves_rd_invariantTheory.TX_PROCESS_MEMORY_READ_REPLY_TRANSITION_PRESERVES_RD_INVARIANT_lemma)) THEN
  ASM_REWRITE_TAC []);

val NIC_AUTONOMOUS_TRANSITION_READS_READABLE_MEMORY_lemma = store_thm (
  "NIC_AUTONOMOUS_TRANSITION_READS_READABLE_MEMORY_lemma",
  ``!nic env nic' mr' int' READABLE WRITABLE.
    NIC_AUTONOMOUS_TRANSITION nic env nic' mr' int' /\
    NIC_INVARIANT nic READABLE WRITABLE /\
    IS_SOME mr' /\ IS_NONE (THE mr').v
    ==>
    READABLE (THE mr').pa``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [txInvariantTheory.TX_INVARIANT_def] THEN
  REWRITE_TAC [tx_transition_definitionsTheory.TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL NIC_AUTONOMOUS_TRANSITION_MEMORY_REQUEST_IMP_TX_OR_RX_MEMORY_REQUEST_lemma)) THEN
  RW_ASM_TAC ``IS_NONE (THE mr').v`` optionTheory.IS_NONE_EQ_NONE THEN
  ASM_RW_ASM_TAC ``(THE mr').v = NONE`` ``P \/ Q`` THEN
  RW_ASM_TAC ``P \/ Q`` optionTheory.IS_SOME_DEF THEN
  SPLIT_ASM_TAC THEN
  KEEP_ASM_RW_ASM_TAC ``TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic`` ``P ==> Q`` THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL tx_transition_preserves_tx_invariant_memory_and_only_reads_readable_memoryTheory.TX_transition_ONLY_READS_READABLE_MEMORY_lemma)) THEN
  ASM_REWRITE_TAC []);

val NIC_AUTONOMOUS_TRANSITION_WRITES_WRITABLE_MEMORY_lemma = store_thm (
  "NIC_AUTONOMOUS_TRANSITION_WRITES_WRITABLE_MEMORY_lemma",
  ``!nic env nic' mr' int' READABLE WRITABLE.
    NIC_AUTONOMOUS_TRANSITION nic env nic' mr' int' /\
    NIC_INVARIANT nic READABLE WRITABLE /\
    IS_SOME mr' /\ IS_SOME (THE mr').v
    ==>
    WRITABLE (THE mr').pa``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [NIC_INVARIANT_def] THEN
  REWRITE_TAC [rxInvariantTheory.RX_INVARIANT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL NIC_AUTONOMOUS_TRANSITION_MEMORY_REQUEST_IMP_TX_OR_RX_MEMORY_REQUEST_lemma)) THEN
  RW_ASM_TAC ``IS_SOME (THE mr').v`` optionTheory.IS_SOME_EXISTS THEN
  PAT_ASSUM ``?x.P`` (fn thm => CHOOSE_TAC thm) THEN
  ASM_RW_ASM_TAC ``(THE mr').v = SOME x`` ``P \/ Q`` THEN
  RW_ASM_TAC ``P \/ Q`` optionTheory.IS_NONE_DEF THEN
  SPLIT_ASM_TAC THEN
  KEEP_ASM_RW_ASM_TAC ``RX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic`` ``P ==> Q`` THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_transition_preserves_rx_invariant_and_only_writes_writable_memoryTheory.rx_transition_WRITES_ONLY_WRITABLE_MEMORY_lemma)) THEN
  ASM_REWRITE_TAC []);

val _ = export_theory();

