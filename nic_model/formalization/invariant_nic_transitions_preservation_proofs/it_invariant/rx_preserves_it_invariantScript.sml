open HolKernel Parse boolLib bossLib;
open helperTactics;
open itInvariantTheory;
open it_state_definitionsTheory;
open rx_transition_lemmasTheory;
open rxInvariantWellDefinedLemmasTheory;
open rx_transition_definitionsTheory;
open rx_state_lemmasTheory;
open rx_invariant_lemmasTheory;

val _ = new_theory "rx_preserves_it_invariant";

val RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE_lemma",
  ``!nic env nic' mr'.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE nic
    ==>
    IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE_def] THEN
  REWRITE_TAC [IT_STATE_INITIALIZED_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_lemma)) THEN
  ASM_RW_ASM_TAC ``nic'.it = nic.it`` ``nic'.it.state <> it_initialized`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``~P`` (GSYM IT_STATE_INITIALIZED_def) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_AUTONOMOUS_TRANSITION_IMP_NOT_RX_STATE_IDLE_OR_IT_STATE_INITIALIZED_NOT_RX_BD_QUEUE_EMPTY_RD_STATE_IDLE_lemma)) THEN
  KEEP_ASM_RW_ASM_TAC ``~P`` ``P \/ Q`` THEN
  ASM_RW_ASM_TAC ``RX_STATE_IDLE nic`` ``~RX_STATE_IDLE nic`` THEN
  UNDISCH_TAC ``F`` THEN
  REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT_lemma",
  ``!nic env nic' mr'.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT nic
    ==>
    IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT_def] THEN
  REWRITE_TAC [IT_STATE_RESET_def] THEN
  REWRITE_TAC [RX0_HDP_INITIALIZED_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_lemma)) THEN
  KEEP_ASM_RW_ASM_TAC ``nic'.it = nic.it`` ``nic'.it.state = it_reset`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  ASM_RW_ASM_TAC ``nic'.it = nic.it`` ``nic'.it.rx0_hdp_initialized`` THEN
  ASM_RW_ASM_TAC ``nic.it.rx0_hdp_initialized`` ``~nic.it.rx0_hdp_initialized`` THEN
  ASM_REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY_lemma",
  ``!nic env nic' mr' WRITABLE.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    RX_INVARIANT nic WRITABLE /\
    IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY nic
    ==>
    IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY_def] THEN
  REWRITE_TAC [IT_STATE_INITIALIZE_HDP_CP_def, RX0_HDP_INITIALIZED_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_lemma)) THEN
  KEEP_ASM_RW_ASM_TAC ``nic'.it = nic.it`` ``nic'.it.state = it_initialize_hdp_cp`` THEN
  ASM_RW_ASM_TAC ``nic'.it = nic.it`` ``nic'.it.rx0_hdp_initialized`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_AUTONOMOUS_TRANSITION_IMP_RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_IMP_RX_STATE_THREE_CASEs_lemma)) THEN
  ASM_CASES_TAC ``RX_STATE_RECEIVE_FRAME nic`` THENL
  [
   ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_RECEIVE_FRAME_IMP_NOT_RX_BD_QUEUE_EMPTY_lemma)) THEN
   ASM_RW_ASM_TAC ``RX_BD_QUEUE_EMPTY nic`` ``~RX_BD_QUEUE_EMPTY nic`` THEN
   UNDISCH_TAC ``F`` THEN
   REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASM_CASES_TAC ``RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM nic`` THENL
  [
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_FETCH_NEXT_BD_OR_ISSUE_MEMORY_REQUEST_OR_WRITE_CPPI_RAM_RX_INVARIANT_IMP_NOT_RX_BD_QUEUE_EMPTY_lemma)) THEN
   ASM_RW_ASM_TAC ``RX_BD_QUEUE_EMPTY nic`` ``~RX_BD_QUEUE_EMPTY nic`` THEN
   UNDISCH_TAC ``F`` THEN
   REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_RX_STATE_WRITE_CP_PRESERVES_RX_BD_QUEUE_EMPTY_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_lemma",
  ``!nic env nic' mr' WRITABLE.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    IT_INVARIANT nic /\
    RX_INVARIANT nic WRITABLE
    ==>
    IT_INVARIANT nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [IT_INVARIANT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_NOT_INIT_IMP_TX_RX_IDLE_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RESET_IMP_NOT_RX_HDP_INIT_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_PRESERVES_IT_INVARIANT_RX_HDP_INITIALIZED_IMP_RX_BD_QUEUE_EMPTY_lemma)) THEN
  ASM_REWRITE_TAC []);

val _ = export_theory();

