open HolKernel Parse boolLib bossLib;
open helperTactics;
open rx_state_definitionsTheory;
open rxTheory;
open rdInvariantTheory;
open rx_transition_lemmasTheory;
open rxInvariantWellDefinedTheory;
open rxInvariantTheory;
open qdInvariantTheory;
open rx_transition_definitionsTheory;
open rx_transition_lemmasTheory;
open rdTheory;
open rx_state_lemmasTheory;
open rxInvariantWellDefinedLemmasTheory;
open tx_transition_definitionsTheory;
open tx_transition_lemmasTheory;

val _ = new_theory "rx_transition_preserves_rd_invariant_current_bd_pa";

val RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma = store_thm (
  "RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma",
  ``!nic WRITABLE.
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic /\
    RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA nic /\
    RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE nic
    ==>
    MEM nic.rx.current_bd_pa (rx_bd_queue nic)``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_idle_initialized_write_cp_IMP_CURRENT_BD_PA_EQ_SOP_BD_PA_def] THEN
  REWRITE_TAC [RX_INVARIANT_CURRENT_BD_PA_IN_BD_QUEUE_def] THEN
  REWRITE_TAC [RX_STATE_WRITE_CP_NOT_BD_QUEUE_EMPTY_def] THEN
  REWRITE_TAC [RD_WRITE_CURRENT_BD_PA_def] THEN
  REWRITE_TAC [RX_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  KEEP_ASM_RW_ASM_TAC ``RX_STATE_WRITE_CP nic`` ``P ==> (x = y)`` THEN
  ASM_RW_ASM_TAC ``RX_STATE_WRITE_CP nic`` ``P ==> Q`` THEN
  ASM_RW_ASM_TAC ``x = y`` ``x <> 0w`` THEN
  ASM_RW_ASM_TAC ``x <> y`` ``P ==> Q`` THEN
  ASM_REWRITE_TAC []);

val RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma = store_thm (
  "RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma",
  ``!nic WRITABLE.
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic /\
    RX_INVARIANT nic WRITABLE
    ==>
    MEM nic.rx.current_bd_pa (rx_bd_queue nic)``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RX_INVARIANT_def] THEN
  REWRITE_TAC [RX_INVARIANT_MEMORY_def] THEN
  REWRITE_TAC [RX_INVARIANT_WELL_DEFINED_def] THEN
  REWRITE_TAC [RX_INVARIANT_BD_QUEUE_STRUCTURE_SUPPORT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_WRITE_CP_IMP_RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma)) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_RX_CURRENT_BD_PA_lemma = store_thm (
  "RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_RX_CURRENT_BD_PA_lemma",
  ``!nic env nic' WRITABLE.
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic /\ 
    RX_INVARIANT nic WRITABLE
    ==>
    BD_IN_CPPI_RAM nic.rx.current_bd_pa``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma)) THEN
  RW_ASM_TAC ``RX_INVARIANT nic WRITABLE`` RX_INVARIANT_def THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_WRITE_CP_IMP_RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma)) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  RW_ASM_TAC ``RX_INVARIANT_MEMORY nic WRITABLE`` RX_INVARIANT_MEMORY_def THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``RX_INVARIANT_WELL_DEFINED nic`` RX_INVARIANT_WELL_DEFINED_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPECL [``nic.rx.current_bd_pa``, ``rx_bd_queue nic``] RX_INVARIANT_BD_QUEUE_LOCATION_DEFINED_MEM_lemma)) THEN
  RW_ASM_TAC ``BD_LOCATION_DEFINED nic.rx.current_bd_pa`` CPPI_RAMTheory.BD_LOCATION_DEFINED_def THEN
  ASM_REWRITE_TAC []);

val rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_NEXT_RX_CURRENT_BD_PA_lemma = store_thm (
  "rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_NEXT_RX_CURRENT_BD_PA_lemma",
  ``!nic env nic' WRITABLE.
    (nic' = rx_19write_cp env nic) /\
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic' /\
    RX_INVARIANT nic WRITABLE
    ==>
    BD_IN_CPPI_RAM nic'.rx.current_bd_pa``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL rx_19write_cp_lemmasTheory.rx_19write_cp_NOT_MODIFIED_lemma)) THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``RD_WRITE_CURRENT_BD_PA nic'`` RD_WRITE_CURRENT_BD_PA_def THEN
  KEEP_ASM_RW_ASM_TAC ``nic'.rx.current_bd_pa = nic.rx.current_bd_pa`` ``nic'.rx.current_bd_pa <> 0w`` THEN
  RW_ASM_TAC ``nic.rx.current_bd_pa <> 0w`` (GSYM RD_WRITE_CURRENT_BD_PA_def) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_RX_CURRENT_BD_PA_lemma)) THEN
  ASM_REWRITE_TAC []);

val RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_BDs_RX_CURRENT_BD_PA_TX_BD_QUEUE_lemma = store_thm (
  "RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_BDs_RX_CURRENT_BD_PA_TX_BD_QUEUE_lemma",
  ``!nic WRITABLE.
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic /\
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    BD_NOT_OVERLAP_BDs nic.rx.current_bd_pa (tx_bd_queue nic)``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [QD_INVARIANT_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL RX_STATE_WRITE_CP_IMP_RX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma)) THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
  RW_ASM_TAC ``BD_QUEUEs_DISJOINT q q'`` bd_queueTheory.BD_QUEUEs_DISJOINT_def THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_MEM_RX_CURRENT_BD_PA_RX_BD_QUEUE_lemma)) THEN
  MATCH_MP_TAC bd_listTheory.MEM_NO_BD_LIST_OVERLAP_IMP_BD_NOT_OVERLAP_BDs_lemma THEN
  EXISTS_TAC ``rx_bd_queue nic`` THEN
  ASM_REWRITE_TAC []);

val rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma = store_thm (
  "rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma",
  ``!nic env nic' WRITABLE.
    (nic' = rx_19write_cp env nic) /\
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic /\
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    BD_NOT_OVERLAP_BDs nic'.rx.current_bd_pa (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_BDs_RX_CURRENT_BD_PA_TX_BD_QUEUE_lemma)) THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL rx_19write_cp_lemmasTheory.rx_19write_cp_NOT_MODIFIED_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (SPEC_ALL tx_bd_queueTheory.EQ_SOP_BD_PA_AND_CPPI_RAM_AND_TX_INVARIANT_BD_QUEUE_FINITE_IMP_EQ_BD_QUEUES_lemma) THEN
  ASM_RW_ASM_TAC ``(nic' : nic_state).tx = nic.tx`` ``P ==> Q`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  ASM_REWRITE_TAC []);

val rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma = store_thm (
  "rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma",
  ``!nic env nic' WRITABLE.
    (nic' = rx_19write_cp env nic) /\
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic' /\
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    BD_NOT_OVERLAP_BDs nic'.rx.current_bd_pa (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  MATCH_MP_TAC rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma THEN
  EXISTS_TAC ``nic : nic_state`` THEN
  EXISTS_TAC ``env : environment`` THEN
  EXISTS_TAC ``WRITABLE : 32 word -> bool`` THEN
  ASM_REWRITE_TAC [RD_WRITE_CURRENT_BD_PA_def] THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL rx_19write_cp_lemmasTheory.rx_19write_cp_NOT_MODIFIED_lemma)) THEN
  RW_ASM_TAC ``RD_WRITE_CURRENT_BD_PA nic'`` RD_WRITE_CURRENT_BD_PA_def THEN
  SPLIT_ASM_TAC THEN
  ASM_RW_ASM_TAC ``nic'.rx.current_bd_pa = nic.rx.current_bd_pa`` ``nic'.rx.current_bd_pa <> 0w`` THEN
  ASM_REWRITE_TAC []);

val rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_NEXT_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma = store_thm (
  "rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_NEXT_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma",
  ``!nic env nic' WRITABLE.
    (nic' = rx_19write_cp env nic) /\
    RX_STATE_WRITE_CP nic /\
    RD_WRITE_CURRENT_BD_PA nic' /\
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic' /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    BD_NOT_OVERLAP_BDs nic'.rx.current_bd_pa (tx_bd_queue nic')``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  MATCH_MP_TAC rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma THEN
  EXISTS_TAC ``nic : nic_state`` THEN
  EXISTS_TAC ``env : environment`` THEN
  EXISTS_TAC ``WRITABLE : 32 word -> bool`` THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL rx_19write_cp_lemmasTheory.rx_19write_cp_NOT_MODIFIED_lemma)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_DEP_lemma)) THEN
  ASM_RW_ASM_TAC ``(nic' : nic_state).tx = nic.tx`` ``P ==> Q`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (UNDISCH thm)) THEN
  ASM_REWRITE_TAC []);

val rx_19write_cp_ESTABLISHES_RD_INVARIANT_CURRENT_BD_PA_lemma = store_thm (
  "rx_19write_cp_ESTABLISHES_RD_INVARIANT_CURRENT_BD_PA_lemma",
  ``!nic env nic' WRITABLE.
    (nic' = rx_19write_cp env nic) /\
    RX_STATE_WRITE_CP nic /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    RD_INVARIANT_CURRENT_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  REWRITE_TAC [RD_INVARIANT_CURRENT_BD_PA_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  RW_ASM_TAC ``RD_STATE_WRITE_CPPI_RAM nic'`` RD_STATE_WRITE_CPPI_RAM_def THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_CURRENT_BD_PA_RX_INVARIANT_IMP_BD_IN_CPPI_RAM_NEXT_RX_CURRENT_BD_PA_lemma)) THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_19write_cp_RX_STATE_WRITE_CP_RD_WRITE_NEXT_CURRENT_BD_PA_NEXT_TX_ACTIVE_RX_QD_INVARIANTs_IMP_BD_NOT_OVERLAP_NEXT_RX_CURRENT_BD_PA_NEXT_TX_BD_QUEUE_lemma)) THEN
  ASM_REWRITE_TAC []);

val EQ_TX_RX_STATE_RX_CURRENT_BD_PA_REGS_PRESERVES_RD_INVARIANT_CURRENT_BD_PA_lemma = store_thm (
  "EQ_TX_RX_STATE_RX_CURRENT_BD_PA_REGS_PRESERVES_RD_INVARIANT_CURRENT_BD_PA_lemma",
  ``!nic nic'.
    RD_INVARIANT_CURRENT_BD_PA nic /\
    (nic'.tx = nic.tx) /\
    (nic'.rx.state = nic.rx.state) /\
    (nic'.rx.current_bd_pa = nic.rx.current_bd_pa) /\
    (nic'.regs = nic.regs)
    ==>
    RD_INVARIANT_CURRENT_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [RD_INVARIANT_CURRENT_BD_PA_def] THEN
  REWRITE_TAC [RD_STATE_WRITE_CPPI_RAM_def] THEN
  REWRITE_TAC [RX_STATE_IDLE_def] THEN
  REWRITE_TAC [RD_WRITE_CURRENT_BD_PA_def] THEN
  REPEAT DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (GSYM (SPECL [``nic' : nic_state``, ``nic : nic_state``] TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_DEP_lemma)) THEN
  KEEP_ASM_RW_ASM_TAC ``(nic' : nic_state).tx = nic.tx`` ``P ==> Q`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
  ASM_RW_ASM_TAC ``nic'.rx.state = nic.rx.state`` ``nic'.rx.state = rx_idle`` THEN
  KEEP_ASM_RW_ASM_TAC ``nic'.rx.current_bd_pa = nic.rx.current_bd_pa`` ``nic'.rx.current_bd_pa <> 0w`` THEN
  PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
  ASSUME_TAC (SPEC_ALL tx_bd_queueTheory.EQ_SOP_BD_PA_AND_CPPI_RAM_AND_TX_INVARIANT_BD_QUEUE_FINITE_IMP_EQ_BD_QUEUES_lemma) THEN
  ASM_RW_ASM_TAC ``(nic' : nic_state).tx = nic.tx`` ``P ==> Q`` THEN
  ASM_RW_ASM_TAC ``(nic' : nic_state).regs = nic.regs`` ``P ==> Q`` THEN
  ASM_REWRITE_TAC []);

val RX_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_CURRENT_BD_PA_lemma = store_thm (
  "RX_AUTONOMOUS_TRANSITION_PRESERVES_RD_INVARIANT_CURRENT_BD_PA_lemma",
  ``!nic env nic' mr' WRITABLE.
    RX_AUTONOMOUS_TRANSITION nic env nic' mr' /\
    RD_INVARIANT_CURRENT_BD_PA nic /\
    RX_INVARIANT nic WRITABLE /\
    QD_INVARIANT nic
    ==>
    RD_INVARIANT_CURRENT_BD_PA nic'``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  REWRITE_TAC [RD_INVARIANT_CURRENT_BD_PA_def] THEN
  REWRITE_TAC [RD_STATE_WRITE_CPPI_RAM_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_NEXT_STATE_IDLE_IMP_CURRENT_STATE_WRITE_CP_OR_TX_RX_STATE_RD_CURRENT_BD_PA_REGS_PRESERVED_lemma)) THEN
  ASM_CASES_TAC ``RX_STATE_WRITE_CP nic`` THENL
  [
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL RX_AUTONOMOUS_TRANSITION_RX_STATE_WRITE_CP_IMP_NEXT_STATE_EQ_rx_19write_cp_lemma)) THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL rx_19write_cp_ESTABLISHES_RD_INVARIANT_CURRENT_BD_PA_lemma)) THEN
   RW_ASM_TAC ``RD_INVARIANT_CURRENT_BD_PA nic'`` RD_INVARIANT_CURRENT_BD_PA_def THEN
   RW_ASM_TAC ``P ==> Q`` RD_STATE_WRITE_CPPI_RAM_def THEN
   PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q`` THEN
   SPLIT_ASM_TAC THEN
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL EQ_TX_RX_STATE_RX_CURRENT_BD_PA_REGS_PRESERVES_RD_INVARIANT_CURRENT_BD_PA_lemma)) THEN
   RW_ASM_TAC ``RD_INVARIANT_CURRENT_BD_PA nic'`` RD_INVARIANT_CURRENT_BD_PA_def THEN
   RW_ASM_TAC ``P ==> Q`` RD_STATE_WRITE_CPPI_RAM_def THEN
   PAT_ASSUM ``P ==> Q`` (fn thm => ASSUME_TAC (CONJ_ANT_TO_HYP thm)) THEN
   ASM_REWRITE_TAC []
  ]);

val _ = export_theory();

