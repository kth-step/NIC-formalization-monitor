open HolKernel Parse boolLib bossLib;
open helperTactics;
open stateTheory;
open tx_state_definitionsTheory;
open tx_transition_definitionsTheory;
open txLib;
open schedulerTheory;

val _ = new_theory "tx_state_lemmas";

val TX_EQ_IMP_TX_STATE_EQ_lemma = store_thm (
  "TX_EQ_IMP_TX_STATE_EQ_lemma",
  ``!nic nic'.
    (nic'.tx = nic.tx)
    ==>
    (nic'.tx.state = nic.tx.state)``,
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_IDLE_DEP_lemma = store_thm (
  "TX_STATE_IDLE_DEP_lemma",
  ``!nic nic'.
    TX_STATE_IDLE nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_IDLE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_FETCH_NEXT_BD_DEP_lemma = store_thm (
  "TX_STATE_FETCH_NEXT_BD_DEP_lemma",
  ``!nic nic'.
    TX_STATE_FETCH_NEXT_BD nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_FETCH_NEXT_BD nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma = store_thm (
  "TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma",
  ``!nic nic'.
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_PROCESS_MEMORY_READ_REPLY_DEP_lemma = store_thm (
  "TX_STATE_PROCESS_MEMORY_READ_REPLY_DEP_lemma",
  ``!nic nic'.
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_POST_PROCESS_DEP_lemma = store_thm (
  "TX_STATE_POST_PROCESS_DEP_lemma",
  ``!nic nic'.
    TX_STATE_POST_PROCESS nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_POST_PROCESS nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_CLEAR_OWNER_AND_HDP_DEP_lemma = store_thm (
  "TX_STATE_CLEAR_OWNER_AND_HDP_DEP_lemma",
  ``!nic nic'.
    TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_CLEAR_OWNER_AND_HDP nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_WRITE_CP_DEP_lemma = store_thm (
  "TX_STATE_WRITE_CP_DEP_lemma",
  ``!nic nic'.
    TX_STATE_WRITE_CP nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_WRITE_CP nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_DEP_lemmas = [
  TX_STATE_IDLE_DEP_lemma,
  TX_STATE_FETCH_NEXT_BD_DEP_lemma,
  TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_DEP_lemma,
  TX_STATE_PROCESS_MEMORY_READ_REPLY_DEP_lemma,
  TX_STATE_POST_PROCESS_DEP_lemma,
  TX_STATE_CLEAR_OWNER_AND_HDP_DEP_lemma,
  TX_STATE_WRITE_CP_DEP_lemma];

val TX_STATE_DEP_CONJ_lemmas = save_thm (
  "TX_STATE_DEP_CONJ_lemmas",
  LIST_CONJ TX_STATE_DEP_lemmas);

val TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_DEP_lemma = store_thm (
  "TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_DEP_lemma",
  ``!nic nic'.
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  Cases_on `TX_STATE_IDLE nic` THENL
  [
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_IDLE_DEP_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  Cases_on `TX_STATE_FETCH_NEXT_BD nic` THENL
  [
   ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_FETCH_NEXT_BD_DEP_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_WRITE_CP_DEP_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_DEP_lemma = store_thm (
  "TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_DEP_lemma",
  ``!nic nic'.
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  DISCH_TAC THEN
  SPLIT_ASM_TAC THEN
  REPEAT (PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val tx_state_application = (#1 o dest_disj o concl) thm in
    let val tx_id = txLib.tx_transition_state_application_to_tx_id tx_state_application in
    let val lemma = txLib.get_tx_conjunct TX_STATE_DEP_CONJ_lemmas tx_id in
      ASSUME_TAC thm THEN
      ASM_CASES_TAC tx_state_application THENL
      [
       ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL lemma)) THEN
       ASM_REWRITE_TAC []
       ,
       ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
      ]
    end end end)) THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (CONJ_ANT_TO_HYP (SPEC_ALL TX_STATE_CLEAR_OWNER_AND_HDP_DEP_lemma)) THEN
  ASM_REWRITE_TAC []);

val TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_NOT_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_NOT_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic
    ==>
    ~TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_def] THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  REWRITE_TAC [TX_STATE_IDLE_def, TX_STATE_FETCH_NEXT_BD_def, TX_STATE_WRITE_CP_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def, TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def, TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM] THEN
  DISCH_TAC THEN
  ASM_CASES_TAC ``nic.tx.state = tx_idle`` THENL
  [
   ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct]
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASM_CASES_TAC ``nic.tx.state = tx_fetch_next_bd`` THENL
  [
   ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct]
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
  ] THEN
  ASM_REWRITE_TAC [GSYM stateTheory.tx_abstract_state_distinct]);

val NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    ~TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_def] THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  REWRITE_TAC [TX_STATE_IDLE_def, TX_STATE_FETCH_NEXT_BD_def, TX_STATE_WRITE_CP_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def, TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def, TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM] THEN
  DISCH_TAC THEN
  CCONTR_TAC THEN
  RW_ASM_TAC ``~P`` boolTheory.DE_MORGAN_THM THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (SPEC ``nic.tx.state`` stateTheory.tx_abstract_state_nchotomy) THEN
  REPEAT (ASM_RW_ASM_TAC ``~P`` ``P \/ Q``) THEN
  ASM_RW_ASM_TAC ``nic.tx.state = tx_issue_next_memory_read_request`` ``~P`` THEN
  UNDISCH_TAC ``F`` THEN
  REWRITE_TAC []);

val TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma = store_thm (
  "TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_IMP_NOT_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma",
  ``!nic.
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic
    ==>
    ~TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic``,
  GEN_TAC THEN
  CCONTR_TAC THEN
  RW_ASM_TAC ``P`` boolTheory.NOT_IMP THEN
  SPLIT_ASM_TAC THEN
  ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_IMP_NOT_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma)) THEN
  ASM_RW_ASM_TAC ``~TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic`` ``TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic`` THEN
  UNDISCH_TAC ``F`` THEN
  REWRITE_TAC []);

val NOT_TX_STATE_IDLE_AND_NOT_TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_OTHER_STATE_lemma = store_thm (
  "NOT_TX_STATE_IDLE_AND_NOT_TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_OTHER_STATE_lemma",
  ``!nic.
    ~TX_STATE_IDLE nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    TX_STATE_FETCH_NEXT_BD nic \/
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic \/
    TX_STATE_POST_PROCESS nic \/
    TX_STATE_CLEAR_OWNER_AND_HDP nic \/
    TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC TX_STATE_defs THEN
  Cases_on `nic.tx.state` THEN
  REWRITE_TAC [stateTheory.tx_abstract_state_distinct]);

val TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_DEP_lemma = store_thm (
  "TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_DEP_lemma",
  ``!nic nic'.
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic /\
    (nic'.tx.state = nic.tx.state)
    ==>
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic'``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_def] THEN
  REWRITE_TAC [schedulerTheory.TX_ENABLE_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_IMP_TX_STATE_CASEs_lemma = store_thm (
  "TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_IMP_TX_STATE_CASEs_lemma",
  ``!nic.
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic
    ==>
    TX_STATE_FETCH_NEXT_BD nic \/
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic \/
    TX_STATE_POST_PROCESS nic \/
    TX_STATE_CLEAR_OWNER_AND_HDP nic \/
    TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_def] THEN
  REWRITE_TAC [schedulerTheory.TX_ENABLE_def] THEN
  REWRITE_TAC [GSYM TX_STATE_IDLE_def] THEN
  REWRITE_TAC [GSYM TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [NOT_TX_STATE_IDLE_AND_NOT_TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_OTHER_STATE_lemma]);

val tx_fetch_next_bd_IMP_TX_STATE_FETCH_NEXT_BD_lemma = store_thm (
  "tx_fetch_next_bd_IMP_TX_STATE_FETCH_NEXT_BD_lemma",
  ``!nic.
    (nic.tx.state = tx_fetch_next_bd)
    ==>
    TX_STATE_FETCH_NEXT_BD nic``,
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def]);

val TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma = store_thm (
  "TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma",
  ``!nic.
    TX_STATE_FETCH_NEXT_BD nic
    ==>
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_def, TX_STATE_FETCH_NEXT_BD_def]);

val TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_FETCH_NEXT_BD_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_FETCH_NEXT_BD nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  ASM_REWRITE_TAC []);



val tx_issue_next_memory_read_request_IMP_TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_lemma = store_thm (
  "tx_issue_next_memory_read_request_IMP_TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_lemma",
  ``!nic.
    (nic.tx.state = tx_issue_next_memory_read_request)
    ==>
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic``,
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def]);

val TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_tx_issue_next_memory_read_request_lemma = store_thm (
  "TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_tx_issue_next_memory_read_request_lemma",
  ``!nic.
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic
    ==>
    (nic.tx.state = tx_issue_next_memory_read_request)``,
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def]);

val TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def, TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def]);

val TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);




val TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_tx_process_memory_read_reply_lemma = store_thm (
  "TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_tx_process_memory_read_reply_lemma",
  ``!nic.
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    (nic.tx.state = tx_process_memory_read_reply)``,
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def]);

val TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  ASM_REWRITE_TAC []);

val TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_PROCESS_MEMORY_READ_REPLY_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def]);



val TX_STATE_POST_PROCESS_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "TX_STATE_POST_PROCESS_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    TX_STATE_POST_PROCESS nic
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_POST_PROCESS_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_POST_PROCESS_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_POST_PROCESS nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def, TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_CLEAR_OWNER_AND_HDP_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma = store_thm (
  "TX_STATE_CLEAR_OWNER_AND_HDP_IMP_TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_lemma",
  ``!nic.
    TX_STATE_CLEAR_OWNER_AND_HDP nic
    ==>
    TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_MEMORY_REQUEST_CPPI_RAM_WRITE_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_IDLE_DISTINCT_lemma = store_thm (
  "TX_STATE_IDLE_DISTINCT_lemma",
  ``!nic.
    TX_STATE_IDLE nic
    ==>
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    ~TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct, GSYM stateTheory.tx_abstract_state_distinct]);

val TX_STATE_PROCESS_MEMORY_READ_REPLY_DISTINCT_lemma = store_thm (
  "TX_STATE_PROCESS_MEMORY_READ_REPLY_DISTINCT_lemma",
  ``!nic.
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    ~TX_STATE_IDLE nic /\
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    ~TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct, GSYM stateTheory.tx_abstract_state_distinct]);

val TX_STATE_CLEAR_OWNER_AND_HDP_DISTINCT_lemma = store_thm (
  "TX_STATE_CLEAR_OWNER_AND_HDP_DISTINCT_lemma",
  ``!nic.
    TX_STATE_CLEAR_OWNER_AND_HDP nic
    ==>
    ~TX_STATE_IDLE nic /\
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct, GSYM stateTheory.tx_abstract_state_distinct]);

val TX_STATE_WRITE_CP_DISTINCT_lemma = store_thm (
  "TX_STATE_WRITE_CP_DISTINCT_lemma",
  ``!nic.
    TX_STATE_WRITE_CP nic
    ==>
    ~TX_STATE_IDLE nic /\
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [GSYM stateTheory.tx_abstract_state_distinct]);

val TX_STATE_CASESs_IMP_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma = store_thm (
  "TX_STATE_CASESs_IMP_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma",
  ``!nic.
    TX_STATE_FETCH_NEXT_BD nic \/
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic \/
    TX_STATE_POST_PROCESS nic \/
    TX_STATE_CLEAR_OWNER_AND_HDP nic \/
    TX_STATE_WRITE_CP nic
    ==>
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_def] THEN
  REWRITE_TAC [TX_ENABLE_def] THEN
  REWRITE_TAC [GSYM TX_STATE_IDLE_def] THEN
  REWRITE_TAC [GSYM TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  ONCE_REWRITE_TAC [boolTheory.MONO_NOT_EQ] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM] THEN
  DISCH_TAC THEN
  ASM_CASES_TAC ``TX_STATE_IDLE nic`` THENL
  [
   ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_IDLE_DISTINCT_lemma)) THEN
   ASM_REWRITE_TAC []
   ,
   ASM_RW_ASM_TAC ``~P`` ``P \/ Q`` THEN
   ASSUME_TAC (UNDISCH (SPEC_ALL TX_STATE_PROCESS_MEMORY_READ_REPLY_DISTINCT_lemma)) THEN
   ASM_REWRITE_TAC []
  ]);

val TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_EQ_TX_STATE_CASESs_lemma = store_thm (
  "TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_EQ_TX_STATE_CASESs_lemma",
  ``!nic.
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic =
    TX_STATE_FETCH_NEXT_BD nic \/
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic \/
    TX_STATE_POST_PROCESS nic \/
    TX_STATE_CLEAR_OWNER_AND_HDP nic \/
    TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  EQ_TAC THENL
  [
   REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_IMP_TX_STATE_CASEs_lemma]
   ,
   REWRITE_TAC [TX_STATE_CASESs_IMP_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma]
  ]);

val TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_EQ_TX_STATE_CASESs_lemma = store_thm (
  "TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_EQ_TX_STATE_CASESs_lemma",
  ``!nic.
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic =
    TX_STATE_FETCH_NEXT_BD nic \/
    TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic \/
    TX_STATE_PROCESS_MEMORY_READ_REPLY nic \/
    TX_STATE_POST_PROCESS nic \/
    TX_STATE_CLEAR_OWNER_AND_HDP nic \/
    TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_EQ_TX_STATE_CASESs_lemma] THEN
  REWRITE_TAC [GSYM boolTheory.DISJ_ASSOC] THEN
  EQ_TAC THEN
  DISCH_TAC THEN
  REPEAT (PAT_ASSUM ``P \/ Q`` (fn thm =>
    let val disj = (#1 o dest_disj o concl) thm in
      ASM_CASES_TAC disj THENL
      [
       ASM_REWRITE_TAC []
       ,
       ASSUME_TAC thm THEN
       ASM_RW_ASM_TAC ``~P`` ``P \/ Q``
      ]
    end)) THEN
  ASM_REWRITE_TAC []);

val TX_STATE_CLEAR_OWNER_AND_HDP_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma = store_thm (
  "TX_STATE_CLEAR_OWNER_AND_HDP_IMP_TX_STATE_NOT_BD_QUEUE_EMPTY_lemma",
  ``!nic.
    TX_STATE_CLEAR_OWNER_AND_HDP nic
    ==>
    TX_STATE_NOT_BD_QUEUE_EMPTY nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_NOT_BD_QUEUE_EMPTY_def] THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC []);

val TX_STATE_WRITE_CP_IMP_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma = store_thm (
  "TX_STATE_WRITE_CP_IMP_TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_lemma",
  ``!nic.
    TX_STATE_WRITE_CP nic
    ==>
    TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP nic``,
  GEN_TAC THEN
  DISCH_TAC THEN
  ASM_REWRITE_TAC [TX_STATE_IDLE_FETCH_NEXT_BD_WRITE_CP_def]);

val NOT_OTHER_TX_STATE_IDLE_IMP_TX_STATE_IDLE_lemma = store_thm (
  "NOT_OTHER_TX_STATE_IDLE_IMP_TX_STATE_IDLE_lemma",
  ``!nic.
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    ~TX_STATE_WRITE_CP nic
    ==>
    TX_STATE_IDLE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  CCONTR_TAC THEN
  PAT_ASSUM ``x <> y`` (fn left => PAT_ASSUM ``P /\ Q`` (fn right => ASSUME_TAC (CONJ left right))) THEN
  RW_ASM_TAC ``P`` (GSYM boolTheory.DE_MORGAN_THM) THEN
  RW_ASM_TAC ``P`` (SPEC ``nic.tx.state`` stateTheory.tx_abstract_state_nchotomy) THEN
  ASM_REWRITE_TAC []);

val NOT_TX_TRANSITION_ENABLE_IMP_TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REPLY_lemma = store_thm (
  "NOT_TX_TRANSITION_ENABLE_IMP_TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REPLY_lemma",
  ``!nic.
    ~TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic
    ==>
    TX_STATE_IDLE nic \/ TX_STATE_PROCESS_MEMORY_READ_REPLY nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_def] THEN
  REWRITE_TAC [schedulerTheory.TX_ENABLE_def] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM] THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def]);

val TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REMPLY_IMP_NOT_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma = store_thm (
  "TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REMPLY_IMP_NOT_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma",
  ``!nic.
    TX_STATE_IDLE nic \/ TX_STATE_PROCESS_MEMORY_READ_REPLY nic
    ==>
    ~TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_def] THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [schedulerTheory.TX_ENABLE_def] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM]);

val NOT_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_EQ_TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REPLY_lemma = store_thm (
  "NOT_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_EQ_TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REPLY_lemma",
  ``!nic. ~TX_STATE_AUTONOMOUS_TRANSITION_ENABLE nic = TX_STATE_IDLE nic \/ TX_STATE_PROCESS_MEMORY_READ_REPLY nic``,
  GEN_TAC THEN
  EQ_TAC THENL
  [
   REWRITE_TAC [NOT_TX_TRANSITION_ENABLE_IMP_TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REPLY_lemma]
   ,
   REWRITE_TAC [TX_STATE_IDLE_OR_PROCESS_MEMORY_READ_REMPLY_IMP_NOT_TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_lemma]
  ]);

val TX_STATE_IDLE_EQ_NOT_OTHER_STATEs_lemma = store_thm (
  "TX_STATE_IDLE_EQ_NOT_OTHER_STATEs_lemma",
  ``!nic.
    TX_STATE_IDLE nic
    =
    ~TX_STATE_FETCH_NEXT_BD nic /\
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    ~TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  EQ_TAC THENL
  [
   REWRITE_TAC [TX_STATE_IDLE_DISTINCT_lemma]
   ,
   REWRITE_TAC [NOT_OTHER_TX_STATE_IDLE_IMP_TX_STATE_IDLE_lemma]
  ]);

val TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_EQ_NOT_TX_STATE_IDLE_lemma = store_thm (
  "TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_EQ_NOT_TX_STATE_IDLE_lemma",
  ``!nic.
    TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY nic = ~TX_STATE_IDLE nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_EQ_NOT_OTHER_STATEs_lemma] THEN
  REWRITE_TAC [boolTheory.DE_MORGAN_THM] THEN
  REWRITE_TAC [TX_STATE_AUTONOMOUS_TRANSITION_ENABLE_OR_PROCESS_MEMORY_READ_REPLY_EQ_TX_STATE_CASESs_lemma]);

val TX_STATE_EQ_idle_OR_fetch_next_bd_NEQ_lemma = store_thm (
  "TX_STATE_EQ_idle_OR_fetch_next_bd_NEQ_lemma",
  ``!nic.
    TX_STATE_IDLE nic \/ TX_STATE_FETCH_NEXT_BD nic
    ==>
    ~TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST nic /\
    ~TX_STATE_PROCESS_MEMORY_READ_REPLY nic /\
    ~TX_STATE_POST_PROCESS nic /\
    ~TX_STATE_CLEAR_OWNER_AND_HDP nic /\
    ~TX_STATE_WRITE_CP nic``,
  GEN_TAC THEN
  REWRITE_TAC [TX_STATE_IDLE_def] THEN
  REWRITE_TAC [TX_STATE_FETCH_NEXT_BD_def] THEN
  REWRITE_TAC [TX_STATE_ISSUE_NEXT_MEMORY_READ_REQUEST_def] THEN
  REWRITE_TAC [TX_STATE_PROCESS_MEMORY_READ_REPLY_def] THEN
  REWRITE_TAC [TX_STATE_POST_PROCESS_def] THEN
  REWRITE_TAC [TX_STATE_CLEAR_OWNER_AND_HDP_def] THEN
  REWRITE_TAC [TX_STATE_WRITE_CP_def] THEN
  DISCH_TAC THEN
  Cases_on `nic.tx.state = tx_idle` THENL
  [
   ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct]
   ,
   ASM_RW_ASM_TAC ``nic.tx.state <> tx_idle`` ``P \/ Q`` THEN
   ASM_REWRITE_TAC [stateTheory.tx_abstract_state_distinct]
  ]);

val _ = export_theory();

